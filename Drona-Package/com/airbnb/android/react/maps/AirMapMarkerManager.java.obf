package com.airbnb.android.react.maps;

import android.graphics.Bitmap;
import android.graphics.Bitmap.Config;
import android.graphics.Color;
import android.view.View;
import com.facebook.react.bridge.ReadableArray;
import com.facebook.react.bridge.ReadableMap;
import com.facebook.react.common.MapBuilder;
import com.facebook.react.uimanager.LayoutShadowNode;
import com.facebook.react.uimanager.ThemedReactContext;
import com.facebook.react.uimanager.ViewGroupManager;
import com.facebook.react.uimanager.annotations.ReactProp;
import com.google.android.gms.maps.model.BitmapDescriptor;
import com.google.android.gms.maps.model.LatLng;
import com.google.android.gms.maps.model.Marker;
import java.util.HashMap;
import java.util.Iterator;
import java.util.Map;
import java.util.Map.Entry;
import java.util.Set;
import java.util.WeakHashMap;
import java.util.concurrent.ConcurrentHashMap;
import javax.annotation.Nullable;

public class AirMapMarkerManager
  extends ViewGroupManager<AirMapMarker>
{
  private static final int ANIMATE_MARKER_TO_COORDINATE = 3;
  private static final int HIDE_INFO_WINDOW = 2;
  private static final int REDRAW = 4;
  private static final int SHOW_INFO_WINDOW = 1;
  private Map<String, AirMapMarkerSharedIcon> sharedIcons = new ConcurrentHashMap();
  
  public AirMapMarkerManager() {}
  
  public void addView(AirMapMarker paramAirMapMarker, View paramView, int paramInt)
  {
    if ((paramView instanceof AirMapCallout))
    {
      paramAirMapMarker.setCalloutView((AirMapCallout)paramView);
      return;
    }
    super.addView(paramAirMapMarker, paramView, paramInt);
    paramAirMapMarker.update(true);
  }
  
  public LayoutShadowNode createShadowNodeInstance()
  {
    return new SizeReportingShadowNode();
  }
  
  public AirMapMarker createViewInstance(ThemedReactContext paramThemedReactContext)
  {
    return new AirMapMarker(paramThemedReactContext, this);
  }
  
  @Nullable
  public Map<String, Integer> getCommandsMap()
  {
    return MapBuilder.of("showCallout", Integer.valueOf(1), "hideCallout", Integer.valueOf(2), "animateMarkerToCoordinate", Integer.valueOf(3), "redraw", Integer.valueOf(4));
  }
  
  @Nullable
  public Map getExportedCustomDirectEventTypeConstants()
  {
    Map localMap = MapBuilder.of("onPress", MapBuilder.of("registrationName", "onPress"), "onCalloutPress", MapBuilder.of("registrationName", "onCalloutPress"), "onDragStart", MapBuilder.of("registrationName", "onDragStart"), "onDrag", MapBuilder.of("registrationName", "onDrag"), "onDragEnd", MapBuilder.of("registrationName", "onDragEnd"));
    localMap.putAll(MapBuilder.of("onDragStart", MapBuilder.of("registrationName", "onDragStart"), "onDrag", MapBuilder.of("registrationName", "onDrag"), "onDragEnd", MapBuilder.of("registrationName", "onDragEnd")));
    return localMap;
  }
  
  public String getName()
  {
    return "AIRMapMarker";
  }
  
  public AirMapMarkerSharedIcon getSharedIcon(String paramString)
  {
    Object localObject = (AirMapMarkerSharedIcon)sharedIcons.get(paramString);
    if (localObject == null) {
      try
      {
        AirMapMarkerSharedIcon localAirMapMarkerSharedIcon = (AirMapMarkerSharedIcon)sharedIcons.get(paramString);
        localObject = localAirMapMarkerSharedIcon;
        if (localAirMapMarkerSharedIcon == null)
        {
          localObject = new AirMapMarkerSharedIcon();
          sharedIcons.put(paramString, localObject);
        }
        return localObject;
      }
      finally {}
    }
    return localObject;
  }
  
  public void receiveCommand(AirMapMarker paramAirMapMarker, int paramInt, @Nullable ReadableArray paramReadableArray)
  {
    switch (paramInt)
    {
    default: 
      return;
    case 4: 
      paramAirMapMarker.updateMarkerIcon();
      return;
    case 3: 
      ReadableMap localReadableMap = paramReadableArray.getMap(0);
      paramInt = paramReadableArray.getInt(1);
      double d = localReadableMap.getDouble("longitude");
      paramAirMapMarker.animateToCoodinate(new LatLng(Double.valueOf(localReadableMap.getDouble("latitude")).doubleValue(), Double.valueOf(d).doubleValue()), Integer.valueOf(paramInt));
      return;
    case 2: 
      ((Marker)paramAirMapMarker.getFeature()).hideInfoWindow();
      return;
    }
    ((Marker)paramAirMapMarker.getFeature()).showInfoWindow();
  }
  
  public void removeSharedIconIfEmpty(String paramString)
  {
    AirMapMarkerSharedIcon localAirMapMarkerSharedIcon = (AirMapMarkerSharedIcon)sharedIcons.get(paramString);
    if (localAirMapMarkerSharedIcon == null) {
      return;
    }
    if (!localAirMapMarkerSharedIcon.hasMarker()) {
      try
      {
        localAirMapMarkerSharedIcon = (AirMapMarkerSharedIcon)sharedIcons.get(paramString);
        if ((localAirMapMarkerSharedIcon != null) && (!localAirMapMarkerSharedIcon.hasMarker())) {
          sharedIcons.remove(paramString);
        }
        return;
      }
      finally {}
    }
  }
  
  public void removeViewAt(AirMapMarker paramAirMapMarker, int paramInt)
  {
    super.removeViewAt(paramAirMapMarker, paramInt);
    paramAirMapMarker.update(true);
  }
  
  @ReactProp(name="anchor")
  public void setAnchor(AirMapMarker paramAirMapMarker, ReadableMap paramReadableMap)
  {
    double d1;
    if ((paramReadableMap != null) && (paramReadableMap.hasKey("x"))) {
      d1 = paramReadableMap.getDouble("x");
    } else {
      d1 = 0.5D;
    }
    double d2;
    if ((paramReadableMap != null) && (paramReadableMap.hasKey("y"))) {
      d2 = paramReadableMap.getDouble("y");
    } else {
      d2 = 1.0D;
    }
    paramAirMapMarker.setAnchor(d1, d2);
  }
  
  @ReactProp(name="calloutAnchor")
  public void setCalloutAnchor(AirMapMarker paramAirMapMarker, ReadableMap paramReadableMap)
  {
    double d1;
    if ((paramReadableMap != null) && (paramReadableMap.hasKey("x"))) {
      d1 = paramReadableMap.getDouble("x");
    } else {
      d1 = 0.5D;
    }
    double d2;
    if ((paramReadableMap != null) && (paramReadableMap.hasKey("y"))) {
      d2 = paramReadableMap.getDouble("y");
    } else {
      d2 = 0.0D;
    }
    paramAirMapMarker.setCalloutAnchor(d1, d2);
  }
  
  @ReactProp(name="coordinate")
  public void setCoordinate(AirMapMarker paramAirMapMarker, ReadableMap paramReadableMap)
  {
    paramAirMapMarker.setCoordinate(paramReadableMap);
  }
  
  @ReactProp(name="description")
  public void setDescription(AirMapMarker paramAirMapMarker, String paramString)
  {
    paramAirMapMarker.setSnippet(paramString);
  }
  
  @ReactProp(defaultBoolean=false, name="draggable")
  public void setDraggable(AirMapMarker paramAirMapMarker, boolean paramBoolean)
  {
    paramAirMapMarker.setDraggable(paramBoolean);
  }
  
  @ReactProp(defaultBoolean=false, name="flat")
  public void setFlat(AirMapMarker paramAirMapMarker, boolean paramBoolean)
  {
    paramAirMapMarker.setFlat(paramBoolean);
  }
  
  @ReactProp(name="icon")
  public void setIcon(AirMapMarker paramAirMapMarker, @Nullable String paramString)
  {
    paramAirMapMarker.setImage(paramString);
  }
  
  @ReactProp(name="identifier")
  public void setIdentifier(AirMapMarker paramAirMapMarker, String paramString)
  {
    paramAirMapMarker.setIdentifier(paramString);
  }
  
  @ReactProp(name="image")
  public void setImage(AirMapMarker paramAirMapMarker, @Nullable String paramString)
  {
    paramAirMapMarker.setImage(paramString);
  }
  
  @ReactProp(defaultFloat=0.0F, name="rotation")
  public void setMarkerRotation(AirMapMarker paramAirMapMarker, float paramFloat)
  {
    paramAirMapMarker.setRotation(paramFloat);
  }
  
  @ReactProp(defaultFloat=1.0F, name="opacity")
  public void setOpacity(AirMapMarker paramAirMapMarker, float paramFloat)
  {
    super.setOpacity(paramAirMapMarker, paramFloat);
    paramAirMapMarker.setOpacity(paramFloat);
  }
  
  @ReactProp(customType="Color", defaultInt=-65536, name="pinColor")
  public void setPinColor(AirMapMarker paramAirMapMarker, int paramInt)
  {
    float[] arrayOfFloat = new float[3];
    Color.colorToHSV(paramInt, arrayOfFloat);
    paramAirMapMarker.setMarkerHue(arrayOfFloat[0]);
  }
  
  @ReactProp(name="title")
  public void setTitle(AirMapMarker paramAirMapMarker, String paramString)
  {
    paramAirMapMarker.setTitle(paramString);
  }
  
  @ReactProp(defaultBoolean=true, name="tracksViewChanges")
  public void setTracksViewChanges(AirMapMarker paramAirMapMarker, boolean paramBoolean)
  {
    paramAirMapMarker.setTracksViewChanges(paramBoolean);
  }
  
  @ReactProp(defaultFloat=0.0F, name="zIndex")
  public void setZIndex(AirMapMarker paramAirMapMarker, float paramFloat)
  {
    super.setZIndex(paramAirMapMarker, paramFloat);
    paramAirMapMarker.setZIndex(Math.round(paramFloat));
  }
  
  public void updateExtraData(AirMapMarker paramAirMapMarker, Object paramObject)
  {
    paramObject = (HashMap)paramObject;
    float f1 = ((Float)paramObject.get("width")).floatValue();
    float f2 = ((Float)paramObject.get("height")).floatValue();
    paramAirMapMarker.update((int)f1, (int)f2);
  }
  
  public static class AirMapMarkerSharedIcon
  {
    private Bitmap bitmap;
    private BitmapDescriptor iconBitmapDescriptor;
    private boolean loadImageStarted = false;
    private Map<AirMapMarker, Boolean> markers = new WeakHashMap();
    
    public AirMapMarkerSharedIcon() {}
    
    public void addMarker(AirMapMarker paramAirMapMarker)
    {
      try
      {
        markers.put(paramAirMapMarker, Boolean.valueOf(true));
        if (iconBitmapDescriptor != null) {
          paramAirMapMarker.setIconBitmapDescriptor(iconBitmapDescriptor, bitmap);
        }
        return;
      }
      finally
      {
        paramAirMapMarker = finally;
        throw paramAirMapMarker;
      }
    }
    
    public boolean hasMarker()
    {
      try
      {
        boolean bool = markers.isEmpty();
        return bool;
      }
      finally
      {
        localObject = finally;
        throw localObject;
      }
    }
    
    public void removeMarker(AirMapMarker paramAirMapMarker)
    {
      try
      {
        markers.remove(paramAirMapMarker);
        return;
      }
      finally
      {
        paramAirMapMarker = finally;
        throw paramAirMapMarker;
      }
    }
    
    public boolean shouldLoadImage()
    {
      try
      {
        if (!loadImageStarted)
        {
          loadImageStarted = true;
          return true;
        }
        return false;
      }
      finally
      {
        localObject = finally;
        throw localObject;
      }
    }
    
    public void updateIcon(BitmapDescriptor paramBitmapDescriptor, Bitmap paramBitmap)
    {
      try
      {
        iconBitmapDescriptor = paramBitmapDescriptor;
        bitmap = paramBitmap.copy(Bitmap.Config.ARGB_8888, true);
        boolean bool = markers.isEmpty();
        if (bool) {
          return;
        }
        Iterator localIterator = markers.entrySet().iterator();
        while (localIterator.hasNext())
        {
          Map.Entry localEntry = (Map.Entry)localIterator.next();
          if (localEntry.getKey() != null) {
            ((AirMapMarker)localEntry.getKey()).setIconBitmapDescriptor(paramBitmapDescriptor, paramBitmap);
          }
        }
        return;
      }
      finally {}
    }
  }
}
